
Working prompt plan:

You are an engineering agent working inside a private GitHub repository named "prc-test". In the root of this repo there is:

- A directory "PRC-Watermark", which is a clone of https://github.com/XuandongZhao/PRC-Watermark.
- A PDF named "2410.07369v4.pdf", which describes the PRC watermark and reports watermark capacities (including 512 bits and higher capacities like 2500 bits for non-attacked images).
- An AGENTS.md file describing your responsibilities for a cropping-robustness experiment and the repository’s binary file policy.

Your goal is to experimentally evaluate how robust the PRC watermark is to image cropping, using the official PRC-Watermark implementation, and to produce clean, reproducible code and results.

High-level objectives

1) Use the PRC-Watermark code to generate images that carry PRC watermarks at two bit lengths: 512 bits and 2500 bits.
2) For each watermark configuration, systematically crop the images so that only specific percentages of the original area are retained: 100, 90, 80, 70, 60, 50, 40, 30, 20, and 10 percent.
3) Use the official PRC detection scripts (from the PRC-Watermark repo) to test detection on each cropped image.
4) For each bit length and each keep percentage, compute detection rates; then:
   - Summarize the results in CSV tables.
   - Plot detection-rate curves.
   - Determine and clearly report robustness thresholds: the smallest keep percentage at which the detection rate is at least 100, 99, 95, and 90 percent.

Binary and image file policy

- Do not commit raw binary or image files into pull requests:
  - No .png, .jpg, .jpeg, .gif, .bmp, .pdf, .pt, .pth, .ckpt, .bin, .npy, .npz, .pkl, .onnx, or similar binary files in PRs.
- Experimental images (original watermarked images, cropped images, temporary plots) should live only in gitignored runtime directories (for example ./data/ and any temporary binaries in ./results/).


# Master Script for Cropping Robustness Experiment (Colab)

This script executes the full PRC watermark cropping robustness experiment within the Google Colab environment. Copy and paste this entire code block into a Colab code cell and run it to perform the experiment, generate CSV results, and produce plots.

```python
### Master Script for Cropping Robustness Experiment

import os
import subprocess
import sys
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt

# --- Configuration ---
# Set the base directory for the prc-test repository
ROOT_DIR = Path('/content/prc-test')
PRC_WATERMARK_DIR = ROOT_DIR / 'PRC-Watermark'
SCRIPTS_DIR = ROOT_DIR / 'scripts'
RESULTS_DIR = ROOT_DIR / 'results' / 'cropping'

# Ensure results directory exists
RESULTS_DIR.mkdir(parents=True, exist_ok=True)

# Common experiment parameters
TEST_NUM = 10 # Number of images to generate/decode per bit length
INF_STEPS = 50
FPR = 1e-05
NOWM = 0
KEEP_PERCENTAGES = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]

# Step 1: Image Generation and Initial Detection (for each bit length)
print("--- Step 1: Generating watermarked images ---")
for bit_length in [512, 2500]:
    print(f"Generating {bit_length}-bit watermarked images...")
    encode_cmd = [
        sys.executable,
        str(PRC_WATERMARK_DIR / 'encode.py'),
        '--test_num', str(TEST_NUM),
        '--method', 'prc',
        '--inf_steps', str(INF_STEPS),
        '--nowm', str(NOWM),
        '--fpr', str(FPR),
        '--bits', str(bit_length),
    ]
    try:
        subprocess.run(encode_cmd, check=True, cwd=PRC_WATERMARK_DIR,
                       capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Error generating {bit_length}-bit watermarked images:")
        print(f"STDOUT: {e.stdout}")
        print(f"STDERR: {e.stderr}")
        raise # Re-raise the exception after printing details

    print(f"Finished generating {bit_length}-bit watermarked images.")

# Step 2: Cropping and Detection
print("--- Step 2: Cropping images and running detection ---")
for bit_length in [512, 2500]:
    print(f"Processing {bit_length}-bit images...")
    run_experiment_cmd = [
        sys.executable,
        str(SCRIPTS_DIR / 'run_prc_cropping_experiment.py'),
        '--bit-length', str(bit_length),
        '--test-num', str(TEST_NUM),
        '--inf-steps', str(INF_STEPS),
        '--fpr', str(FPR),
        '--nowm', str(NOWM),
        '--bits', str(bit_length),
        '--keep-percentages',
    ] + [str(p) for p in KEEP_PERCENTAGES]

    # Set input-dir dynamically based on exp_id generated by encode.py
    exp_id = f'prc_num_{TEST_NUM}_steps_{INF_STEPS}_fpr_{FPR}_nowm_{NOWM}_bits_{bit_length}'
    input_original_images_dir = PRC_WATERMARK_DIR / 'results' / exp_id / 'original_images'
    output_root_dir = PRC_WATERMARK_DIR / 'results' / exp_id

    run_experiment_cmd += ['--input-dir', str(input_original_images_dir)]

    # run_prc_cropping_experiment.py takes output_root for cropping, which should be the exp_id directory
    # but it implicitly constructs it based on exp_id, so we don't pass output-root directly unless needed

    # Ensure the raw CSV output path is correct
    raw_csv_path = RESULTS_DIR / f'prc_cropping_raw_{bit_length}bits.csv'
    run_experiment_cmd += ['--raw-out', str(raw_csv_path)]

    try:
        subprocess.run(run_experiment_cmd, check=True, cwd=PRC_WATERMARK_DIR,
                       capture_output=True, text=True)
    except subprocess.CalledProcessError as e:
        print(f"Error running cropping experiment for {bit_length}-bit images:")
        print(f"STDOUT: {e.stdout}")
        print(f"STDERR: {e.stderr}")
        raise # Re-raise the exception after printing details

    print(f"Finished cropping and detection for {bit_length}-bit images.")

# Step 3: Aggregation and Robustness Thresholds
print("--- Step 3: Aggregating results and determining thresholds ---")
analyze_cmd = [
    sys.executable,
    str(SCRIPTS_DIR / 'analyze_cropping_results.py'),
    '--raw', str(RESULTS_DIR / 'prc_cropping_raw_512bits.csv'),
    str(RESULTS_DIR / 'prc_cropping_raw_2500bits.csv'),
    '--output-dir', str(RESULTS_DIR)
]
subprocess.run(analyze_cmd, check=True)
print("Results aggregated and thresholds determined.")

# Step 4: Plotting and Visualization
print("--- Step 4: Generating plots ---")
plot_cmd = [
    sys.executable,
    str(SCRIPTS_DIR / 'plot_cropping_results.py'),
    '--inputs', str(RESULTS_DIR / 'prc_cropping_results_512bits.csv'),
    str(RESULTS_DIR / 'prc_cropping_results_2500bits.csv'),
    '--output-dir', str(RESULTS_DIR)
]
subprocess.run(plot_cmd, check=True)
print("Plots generated.")

# Step 5: Displaying Results (Table and Plots)
print("--- Step 5: Displaying Results ---")

print("--- Aggregated 512-bit Results ---")
aggregated_512_df = pd.read_csv(RESULTS_DIR / 'prc_cropping_results_512bits.csv')
print(aggregated_512_df.to_markdown(index=False))

print("--- Aggregated 2500-bit Results ---")
aggregated_2500_df = pd.read_csv(RESULTS_DIR / 'prc_cropping_results_2500bits.csv')
print(aggregated_2500_df.to_markdown(index=False))

print("--- Robustness Thresholds ---")
thresholds_df = pd.read_csv(RESULTS_DIR / 'prc_cropping_thresholds.csv')
print(thresholds_df.to_markdown(index=False))

print("--- Generated Plots ---")
# Display 512-bit plot
plot_512_path = RESULTS_DIR / 'prc_cropping_summary_512bits.png'
if plot_512_path.exists():
    from IPython.display import Image, display
    print(f"Displaying 512-bit watermark plot from {plot_512_path}:")
    display(Image(filename=str(plot_512_path)))
else:
    print(f"512-bit plot not found at {plot_512_path}")

# Display 2500-bit plot
plot_2500_path = RESULTS_DIR / 'prc_cropping_summary_2500bits.png'
if plot_2500_path.exists():
    from IPython.display import Image, display
    print(f"Displaying 2500-bit watermark plot from {plot_2500_path}:")
    display(Image(filename=str(plot_2500_path)))
else:
    print(f"2500-bit plot not found at {plot_2500_path}")

print("Experiment complete.")
```

Basic PRC-Watermark usage you should rely on

All of these commands are run inside the PRC-Watermark directory; you must adapt test_num N and paths as appropriate.

- Generate N watermarked images and a key:

  mkdir -p keys
  python encode.py --test_num N

- Decode watermarks from the default test images:

  python decode.py --test_num N

- Decode watermarks from attacked (cropped) images stored in a different test folder:

  python decode.py --test_num N --test_path path_to_cropped_images

- Optionally set the targeted False Positive Rate (FPR), default is 0.00001:

  python decode.py --test_num N --fpr 0.00001

You may adjust model_id and dataset_id in configuration files if necessary, but keep changes minimal; follow the defaults for this experiment unless there is a compelling reason to change them.

Concrete workflow to implement

1) Environment setup
   - Inspect "./PRC-Watermark" and its README to learn:
     - How to install dependencies.
     - How to download and configure the required diffusion model weights.
     - How encode.py and decode.py expect their inputs and configuration.
   - Provide a short setup script or README section in the prc-test repo (not inside PRC-Watermark) that lists the exact commands needed to prepare the environment.
   - Ensure ./data/ and any other heavy/binary directories are gitignored.

2) Image generation

   For each bit length b in {512, 2500}:

   - Configure PRC-Watermark so that encode.py produces watermarked images with b watermark bits.
   - Choose a fixed set of prompts, either from PRC-Watermark’s default dataset or a small curated list; use the same prompt set for both bit lengths.
   - Decide on a test_num N (e.g. between 200 and 1000 per bit length) and generate N watermarked images for each b using encode.py.
   - Save original watermarked images into runtime-only directories:
     - ./data/images/512bits/original/
     - ./data/images/2500bits/original/
   - Log metadata for each image in a CSV (safe to commit), including:
     - image_id or filename
     - prompt_id or prompt text
     - bit_length
     - generation seed
     - any key/config identifiers as needed.
   - Verify that detections on unmodified images are as expected:
     - Use decode.py (with or without test_path, depending on where images are stored).
     - Confirm high true positive rate for both 512-bit and 2500-bit settings; log any unexpected failures.

3) Cropping implementation

   - Implement a deterministic central cropping function in a script under ./scripts/, such as crop_images.py.
   - For each image and each keep percentage p in {100, 90, 80, 70, 60, 50, 40, 30, 20, 10}:
     - Let a = p / 100.
     - Compute s = sqrt(a).
     - For an image of size W x H, compute:
       - Wc = round(W * s)
       - Hc = round(H * s)
     - Crop the centered Wc x Hc patch.
     - Resize back to the resolution expected by decode.py if necessary.
     - Save cropped images into runtime-only directories:
       - ./data/images/{bit_length}bits/crop_{p}/
   - Maintain a CSV mapping original images to cropped images and recording crop parameters.

   These image directories are for local experiments only and must not be committed.

4) Detection on cropped images

   - For each bit_length and each keep percentage p:
     - Run decode.py with:
       - test_num equal to the number of images being evaluated.
       - test_path pointing at the relevant cropped directory; for example:

         python decode.py --test_num N --test_path ./data/images/512bits/crop_90

     - Capture the binary detection outputs (detected/not detected) and any scores, if decode.py exposes them.
   - Record detection results in text CSV files in ./results/cropping/:
     - prc_cropping_raw_512bits.csv
     - prc_cropping_raw_2500bits.csv

   Each row should contain at least:

   - image_id
   - prompt_id
   - bit_length
   - keep_percentage
   - detected (0 or 1)
   - detector_score (optional)

5) Aggregation and robustness thresholds

   - Write a separate analysis script (for example ./scripts/analyze_cropping_results.py) that:
     - Loads prc_cropping_raw_*.csv.
     - Aggregates detection statistics by bit_length and keep_percentage:
       - n_images
       - n_detected
       - detection_rate = n_detected / n_images
     - Writes summary CSV files:
       - prc_cropping_results_512bits.csv
       - prc_cropping_results_2500bits.csv
   - For each bit length separately, compute robustness thresholds for target success levels s in {1.0, 0.99, 0.95, 0.90}:
     - Find the smallest keep_percentage p with detection_rate >= s.
     - If no such p exists, note that the threshold is not achieved within the tested crop levels.

6) Plotting and handling plot artifacts

   - Using a plotting script (for example ./scripts/plot_cropping_results.py), construct two plots:

     Plot 1: 512-bit watermark

     - x-axis: keep percentage.
     - y-axis: detection rate.
     - Curve: detection_rate for each keep_percentage.
     - Horizontal reference lines at 1.0, 0.99, 0.95, 0.90.
     - Annotations marking robustness thresholds.

     Plot 2: 2500-bit watermark

     - Same design for 2500-bit results.

   - Save each plot initially as a .png file:
     - ./results/cropping/prc_cropping_summary_512bits.png
     - ./results/cropping/prc_cropping_summary_2500bits.png


   - The generated plot files (PNG format) should be saved directly as:
     - ./results/cropping/prc_cropping_summary_512bits.png
     - ./results/cropping/prc_cropping_summary_2500bits.png

7) Final report

   - Create or update ./results/cropping/REPORT.md with:
     - A concise description of:
       - Models and configuration used (bit lengths, FPR, default model/dataset).
       - Prompt selection and number of images per bit length.
     - Tables showing detection rates by keep percentage for each bit length.
     - A table summarizing robustness thresholds (bit_length, target_success_level, threshold_keep_percentage).
     - References to the plot files (PNG format).
     - Any observations about differences between 512-bit and 2500-bit robustness under cropping.

Quality expectations

- Use simple, reproducible entry points, for example:

  - python scripts/run_prc_cropping_experiment.py --bit-length 512
  - python scripts/run_prc_cropping_experiment.py --bit-length 2500

- Keep all new code and scripts under the prc-test repo (not within PRC-Watermark itself), and refer into PRC-Watermark via imports or subprocess calls.
- Keep all configuration (paths, prompts, number of images, crop percentages) centralized.
- Maintain the invariant that pull requests contain no experimental binary/image files, only text files and final plot files (PNG format).
